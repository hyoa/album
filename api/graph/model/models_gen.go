// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type ActionResult struct {
	Success *bool `json:"success"`
}

type Album struct {
	Title        string        `json:"title"`
	Description  *string       `json:"description"`
	Private      *bool         `json:"private"`
	Author       string        `json:"author"`
	CreationDate int           `json:"creationDate"`
	ID           string        `json:"id"`
	Slug         string        `json:"slug"`
	Medias       []*MediaAlbum `json:"medias"`
}

type AskResetPasswordInput struct {
	Email string `json:"email"`
}

type Auth struct {
	Token string `json:"token"`
}

type AuthInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type ChangeFolderNameInput struct {
	OldName string `json:"oldName"`
	NewName string `json:"newName"`
}

type ChangeMediasFolderInput struct {
	Keys       []string `json:"keys"`
	FolderName string   `json:"folderName"`
}

type CreateAlbumInput struct {
	Title       string  `json:"title"`
	Author      string  `json:"author"`
	Description *string `json:"description"`
	Private     bool    `json:"private"`
}

type CreateInput struct {
	Email         string `json:"email"`
	Password      string `json:"password"`
	PasswordCheck string `json:"passwordCheck"`
	Name          string `json:"name"`
}

type DeleteAlbumInput struct {
	Slug string `json:"slug"`
}

type Folder struct {
	Name   string   `json:"name"`
	Medias []*Media `json:"medias"`
}

type GetAlbumInput struct {
	Slug string `json:"slug"`
}

type GetAlbumsInput struct {
	IncludePrivate  *bool   `json:"includePrivate"`
	IncludeNoMedias *bool   `json:"includeNoMedias"`
	Limit           *int    `json:"limit"`
	Offset          *int    `json:"offset"`
	Term            *string `json:"term"`
	Order           *string `json:"order"`
}

type GetFolderInput struct {
	Name string `json:"name"`
}

type GetFoldersInput struct {
	Name *string `json:"name"`
}

type GetIngestInput struct {
	Medias []*GetIngestMediaInput `json:"medias"`
}

type GetIngestMediaInput struct {
	Kind MediaType `json:"kind"`
	Key  string    `json:"key"`
}

type GetIngestMediaOutput struct {
	Key       string `json:"key"`
	SignedURI string `json:"signedUri"`
}

type GetUserInput struct {
	Email string `json:"email"`
}

type Invitation struct {
	Email string `json:"email"`
}

type InviteInput struct {
	Email string `json:"email"`
}

type Media struct {
	Key    string    `json:"key"`
	Author string    `json:"author"`
	Kind   MediaType `json:"kind"`
	Folder string    `json:"folder"`
	Urls   *Urls     `json:"urls"`
}

type MediaAlbum struct {
	Key      string    `json:"key"`
	Author   string    `json:"author"`
	Kind     MediaType `json:"kind"`
	Urls     *Urls     `json:"urls"`
	Favorite *bool     `json:"favorite"`
}

type MediaAlbumInput struct {
	Key    string    `json:"key"`
	Author string    `json:"author"`
	Kind   MediaType `json:"kind"`
}

type PutIngestInput struct {
	Medias []*PutIngestMediaInput `json:"medias"`
}

type PutIngestMediaInput struct {
	Key    string    `json:"key"`
	Author string    `json:"author"`
	Kind   MediaType `json:"kind"`
	Folder string    `json:"folder"`
}

type PutIngestMediaOutput struct {
	Key    string               `json:"key"`
	Status PutIngestMediaStatus `json:"status"`
}

type ResetPasswordInput struct {
	Password        string `json:"password"`
	PasswordCheck   string `json:"passwordCheck"`
	TokenValidation string `json:"tokenValidation"`
}

type UpdateAlbumFavoriteInput struct {
	Slug     string `json:"slug"`
	MediaKey string `json:"mediaKey"`
}

type UpdateAlbumInput struct {
	Slug        string `json:"slug"`
	Title       string `json:"title"`
	Author      string `json:"author"`
	Description string `json:"description"`
	Private     bool   `json:"private"`
}

type UpdateAlbumMediasInput struct {
	Slug   string                   `json:"slug"`
	Medias []*MediaAlbumInput       `json:"medias"`
	Action *ActionUpdateAlbumMedias `json:"action"`
}

type UpdateInput struct {
	Email string `json:"email"`
	Role  *Role  `json:"role"`
}

type Urls struct {
	Small  string `json:"small"`
	Medium string `json:"medium"`
	Large  string `json:"large"`
}

type User struct {
	Name       string `json:"name"`
	Email      string `json:"email"`
	CreateDate int    `json:"createDate"`
	Role       Role   `json:"role"`
}

type ActionUpdateAlbumMedias string

const (
	ActionUpdateAlbumMediasAdd    ActionUpdateAlbumMedias = "ADD"
	ActionUpdateAlbumMediasRemove ActionUpdateAlbumMedias = "REMOVE"
)

var AllActionUpdateAlbumMedias = []ActionUpdateAlbumMedias{
	ActionUpdateAlbumMediasAdd,
	ActionUpdateAlbumMediasRemove,
}

func (e ActionUpdateAlbumMedias) IsValid() bool {
	switch e {
	case ActionUpdateAlbumMediasAdd, ActionUpdateAlbumMediasRemove:
		return true
	}
	return false
}

func (e ActionUpdateAlbumMedias) String() string {
	return string(e)
}

func (e *ActionUpdateAlbumMedias) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionUpdateAlbumMedias(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionUpdateAlbumMedias", str)
	}
	return nil
}

func (e ActionUpdateAlbumMedias) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MediaType string

const (
	MediaTypePhoto MediaType = "PHOTO"
	MediaTypeVideo MediaType = "VIDEO"
)

var AllMediaType = []MediaType{
	MediaTypePhoto,
	MediaTypeVideo,
}

func (e MediaType) IsValid() bool {
	switch e {
	case MediaTypePhoto, MediaTypeVideo:
		return true
	}
	return false
}

func (e MediaType) String() string {
	return string(e)
}

func (e *MediaType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaType", str)
	}
	return nil
}

func (e MediaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PutIngestMediaStatus string

const (
	PutIngestMediaStatusSuccess      PutIngestMediaStatus = "SUCCESS"
	PutIngestMediaStatusAlreadyExist PutIngestMediaStatus = "ALREADY_EXIST"
	PutIngestMediaStatusFailed       PutIngestMediaStatus = "FAILED"
)

var AllPutIngestMediaStatus = []PutIngestMediaStatus{
	PutIngestMediaStatusSuccess,
	PutIngestMediaStatusAlreadyExist,
	PutIngestMediaStatusFailed,
}

func (e PutIngestMediaStatus) IsValid() bool {
	switch e {
	case PutIngestMediaStatusSuccess, PutIngestMediaStatusAlreadyExist, PutIngestMediaStatusFailed:
		return true
	}
	return false
}

func (e PutIngestMediaStatus) String() string {
	return string(e)
}

func (e *PutIngestMediaStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PutIngestMediaStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PutIngestMediaStatus", str)
	}
	return nil
}

func (e PutIngestMediaStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Role string

const (
	RoleUnidentified Role = "UNIDENTIFIED"
	RoleNormal       Role = "NORMAL"
	RoleAdmin        Role = "ADMIN"
)

var AllRole = []Role{
	RoleUnidentified,
	RoleNormal,
	RoleAdmin,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleUnidentified, RoleNormal, RoleAdmin:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
